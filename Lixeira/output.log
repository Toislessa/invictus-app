Chat, primeiramente, preciso te dizer que este código deu este erro aqui:
File "pandas\_libs\lib.pyx", line 2834, in pandas._libs.lib.map_infer
  File "D:\Projeto Intervalos\intervalos.py", line 143, in <lambda>
    df.iloc[:, col] = df.iloc[:, col].apply(lambda x: int(x) if x != "" else x)
                                                     ^^^^^^
ValueError: invalid literal for int() with base 10: '<div style="background-image: url(./images/Fim.png);">13</div>'
Process finished with exit code 1

Segundo, Você precisa analisar todo o código, pois você continua se equivocando na lógica que você imprime ao Script. Veja esta parte aqui do log do console:
0
06:45
Last payer: 5
payers: [4, 9, 7, 2, 2, 4, 9, 3, 13, 8, 7, 11, 14, 8, 12, 9, 4, 12, 2, 6, 14, 1, 12, 9, 2, 3, 7, 13, 4, 10, 14, 4, 10, 14, 12, 8, 6, 13, 14, 6, 4, 14, 0, 4, 11, 3, 13, 8, 5]
current_cycle_numbers: {0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14}
cycle_numbers: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14} 

Analise ele e verá o seguinte:
Você criou 'current_cycle_numbers' para receber os numéros pagantes. Todavia, ele está sendo sempre o conjunto de numeros de 1 a 14, igualmente 'cycle_numbers'. Isto é, inclusive, redundante, pois não preciso de dois conjuntos deste. Veja neste recorte do log que, às 06:45, saiu um Zero. Foi identificado, corretamente, o número pagante (Last payer) como '5'. O 'Last payer' foi adicionado à payers. E 'current_cycle_numbers' e 'cycle_numbers' estão iguais, ou seja o conjunto  {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14} . Para piorar, você compara duas coisas iguais aqui:  'if cycle_numbers.issubset(current_cycle_numbers)'. Assim, este código nunca vai dar certo. Se você criou 'current_cycle_numbers', para receber os numeros pagantes, deve fazer com que ele receba os números pagantes. Simples!! O 'payers' é usado pelo script para atualizar a célula na coluna "Pagante". 
Tudo errado!!

Eu EXIJO que você revise TODO o código, pois, há linhas acima que impactam nesta parte do código, inclusive, a definição de quem é 'current_cycle_numbers', 'payers' e 'cycle_numbers'. Analise com calma e refaça do zero o código utilizando a lógica e comandos corretos. Não pode mais ficar errando uma coisa tão simples. Lembre-se que lhe contratei para ser o meu Dev, especialista em programação, que deve me entregar um projeto funcional.
Vou postar o meu código abaixo:











Chat, não deu certo. Mas, identifiquei uma coisa, colocando uns prints em 4 pontos diferentes do script. Veja o código e o logo do console e LEIA O MEU COMENTÁRIO NO FINAL:

1 - CÓDIGO:
def main():
    print("Running intervalos.py")
    total_pages = 11
    rolls = []  # Lista para armazenar os números
    times = []  # Lista para armazenar os horários
    zeros = []  # Lista para armazenar os zeros
    zero_times = []  # Lista para armazenar os horários dos zeros
    intervals = []  # Lista para armazenar os intervalos entre os zeros
    interval_count = 0  # Contador para o intervalo atual entre os zeros
    first_zero_found = False  # Flag para indicar se o primeiro zero foi encontrado
    payers = []  # Lista para armazenar os números pagadores
    cycle_numbers = set(range(1, 15))  # Conjunto de números para um ciclo completo
    current_cycle_numbers = set()  # Conjunto de números para o ciclo atual
    print(f"current_cycle_numbers1: {current_cycle_numbers}")

    for page in reversed(range(1, total_pages)):
        result_json = (requests.get("https://blaze.com/api/roulette_games/history?page=" + str(page))).json()
        resultados = reversed(result_json['records'])
        for resultado in resultados:
            roll = resultado['roll']
            created_at = resultado['created_at']

            created_at_datetime = datetime.strptime(created_at, "%Y-%m-%dT%H:%M:%S.%fZ")
            created_at_datetime = created_at_datetime - timedelta(hours=3)

            if created_at_datetime.date() != datetime.now().date():
                continue

            created_at_str = created_at_datetime.strftime("%H:%M")

            print(roll)
            print(created_at_str)

            rolls.append(roll)
            times.append(created_at_str)
            print(f"current_cycle_numbers2: {current_cycle_numbers}")
            if roll == 0:
                zeros.append(roll)
                zero_times.append(created_at_str)
                if first_zero_found:
                    intervals.append(interval_count)
                interval_count = 0
                first_zero_found = True

                if rolls:
                    last_payer = rolls[-2] if len(rolls) > 1 else None
                    payers.append(last_payer)
                    print(f"current_cycle_numbers3: {current_cycle_numbers}")
                    current_cycle_numbers.add(last_payer)  # Adicione o número pagador a current_cycle_numbers aqui
                    print(f"current_cycle_numbers4: {current_cycle_numbers}")
                    print(f"Last payer: {last_payer}")
                    print(f"payers: {payers}")
                    print(f"current_cycle_numbers: {current_cycle_numbers}")
                    print(f"cycle_numbers: {cycle_numbers}")
                    if cycle_numbers.issubset(current_cycle_numbers):
                        print("Cycle completed!")
                        last_payer = f'<div style="background-image: url(./images/Fim.png);">{last_payer}</div>'
                        payers[-1] = last_payer
                        current_cycle_numbers = set()  # Reinicie current_cycle_numbers aqui

            elif first_zero_found:
                interval_count += 1
                print(f"Roll:{roll}, Created at: {created_at_str}, Interval count: {interval_count}")
        time.sleep(1)

2 - LOG
current_cycle_numbers1: set()
0
06:45
current_cycle_numbers2: {0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14}
current_cycle_numbers3: {0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14}
current_cycle_numbers4: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
Last payer: 5
payers: [4, 9, 7, 2, 2, 4, 9, 3, 13, 8, 7, 11, 14, 8, 12, 9, 4, 12, 2, 6, 14, 1, 12, 9, 2, 3, 7, 13, 4, 10, 14, 4, 10, 14, 12, 8, 6, 13, 14, 6, 4, 14, 0, 4, 11, 3, 13, 8, 5]
current_cycle_numbers: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
cycle_numbers: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
Cycle completed!

COMENTÁRIO: 
1 - Note que o print 'current_cycle_numbers1', no começo do código, mostrou o resultado: set()
2 - Note que o segundo print 'current_cycle_numbers2', antes de 'if roll == 0:', deu o resultado CURIOSO: {0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14}
3 - note que o terceiro print 'current_cycle_numbers3'